<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0" />
<title>Molecular Viewer (Havok + Ortho + Clean Silhouettes)</title>
<style>
html,body{margin:0;height:100%;overflow:hidden;background:white;}
#renderCanvas{width:100%;height:100%;display:block;}
#ui{
  position:absolute;top:10px;left:10px;z-index:10;
  background:rgba(0,0,0,0.7);color:white;
  padding:10px;border-radius:8px;
  font-family:Arial;font-size:13px;
}
#zoomSlider,#speedSlider{width:240px;}
button{width:240px;margin-top:6px;}
#dialog{
  position:absolute;left:50%;top:18px;transform:translateX(-50%);z-index:20;
  background:rgba(0,0,0,0.85);color:white;
  padding:10px 12px;border-radius:8px;
  font-family:Arial;font-size:13px;
  min-width:280px;max-width:520px;
  display:none;
}
#dialogClose{
  float:right;cursor:pointer;
  padding:0 6px;border-radius:4px;
  background:rgba(255,255,255,0.15);
}
#dialog pre{margin:8px 0 0 0;white-space:pre-wrap;}
.small{opacity:.85;font-size:12px;margin-top:6px;line-height:1.25;}
hr{border:none;border-top:1px solid rgba(255,255,255,0.15);margin:8px 0;}
</style>
</head>
<body>

<canvas id="renderCanvas"></canvas>

<div id="ui">
  Zoom (ortho size): <span id="zoomVal">120</span><br>
  <input type="range" id="zoomSlider" min="1" max="2000" value="120">
  <br><br>
  Water speed: <span id="speedVal">1.00</span><br>
  <input type="range" id="speedSlider" min="0" max="300" value="100">
  <br>
  <button id="centerBtn">Center View</button>
  <hr>
  <div id="info">Loading...</div>
  <div class="small">
    Controls:<br>
    • Right-drag = pan<br>
    • Ctrl + left-drag = rotate<br>
    • Left click = atom info<br>
    • Wheel = zoom
  </div>
</div>

<div id="dialog">
  <span id="dialogClose">×</span>
  <div><b>Atom info</b></div>
  <pre id="dialogBody"></pre>
</div>

<!-- Havok first (UMD) -->
<script src="https://cdn.babylonjs.com/havok/HavokPhysics_umd.js"></script>
<script src="https://cdn.babylonjs.com/babylon.js"></script>

<script>
window.addEventListener("DOMContentLoaded", async ()=>{

// ----------------------
// DOM
// ----------------------
const canvas    = document.getElementById("renderCanvas");
const infoEl    = document.getElementById("info");
const dialog    = document.getElementById("dialog");
const dialogBody= document.getElementById("dialogBody");
document.getElementById("dialogClose").onclick = ()=> dialog.style.display="none";

canvas.addEventListener("contextmenu", e=>e.preventDefault());
window.addEventListener("wheel", e=>{ if(e.ctrlKey) e.preventDefault(); }, {passive:false});

// ----------------------
// Engine/Scene
// ----------------------
const engine = new BABYLON.Engine(canvas, true, {
  preserveDrawingBuffer:false,
  stencil:true,               // IMPORTANT for depth/edge post fx stability on some GPUs
  antialias:true
});
const scene  = new BABYLON.Scene(engine);
scene.clearColor = new BABYLON.Color4(1,1,1,1);

// Flat look: we disable lighting on our materials, but keep a light anyway.
new BABYLON.HemisphericLight("h", new BABYLON.Vector3(0,1,0), scene);

// ----------------------
// Camera: ArcRotate, ORTHO
// ----------------------
const camera = new BABYLON.ArcRotateCamera("cam",
  Math.PI/2, Math.PI/3,
  120,
  BABYLON.Vector3.Zero(),
  scene
);
camera.mode = BABYLON.Camera.PERSPECTIVE_CAMERA;

camera.minZ = 0.001;
camera.maxZ = 100000;
camera.lowerBetaLimit = 0.10;
camera.upperBetaLimit = Math.PI - 0.10;

// We use radius as the orthographic "size" (bigger = zoomed out).
camera.lowerRadiusLimit = 1;
camera.upperRadiusLimit = 2000;

function updateOrthoFromRadius(){
  const r = camera.radius;
  const aspect = engine.getAspectRatio(camera);
  camera.orthoLeft   = -r * aspect;
  camera.orthoRight  =  r * aspect;
  camera.orthoTop    =  r;
  camera.orthoBottom = -r;
}

// ----------------------
// UI: Zoom + Speed
// ----------------------
const zoomSlider = document.getElementById("zoomSlider");
const zoomVal    = document.getElementById("zoomVal");
zoomSlider.addEventListener("input", ()=>{
  camera.radius = parseFloat(zoomSlider.value);
});
scene.onBeforeRenderObservable.add(()=>{
  zoomVal.textContent = Math.round(camera.radius);
  zoomSlider.value = camera.radius;
});

canvas.addEventListener("wheel", (e)=>{
  if(e.ctrlKey) return;
  e.preventDefault();
  const delta = Math.sign(e.deltaY);
  camera.radius *= (delta>0 ? 1.08 : 0.92);
  camera.radius = Math.max(camera.lowerRadiusLimit, Math.min(camera.radius, camera.upperRadiusLimit));
},{passive:false});

let speedMult = 1.0;
const speedSlider = document.getElementById("speedSlider");
const speedVal    = document.getElementById("speedVal");
speedSlider.addEventListener("input", ()=>{
  speedMult = parseFloat(speedSlider.value)/100;
  speedVal.textContent = speedMult.toFixed(2);
});

// ----------------------
// Flat material helpers
// ----------------------
function makeVertexColorMat(name){
  const m = new BABYLON.StandardMaterial(name, scene);
  m.disableLighting = true;
  m.useVertexColor  = true;
  m.emissiveColor   = BABYLON.Color3.White();  // makes vertex colors visible even with lighting off
  m.specularColor   = BABYLON.Color3.Black();
  m.freeze();
  return m;
}
function makeFlatColorMat(name, c3){
  const m = new BABYLON.StandardMaterial(name, scene);
  m.disableLighting = true;
  m.emissiveColor   = c3.clone();
  m.diffuseColor    = c3.clone();
  m.specularColor   = BABYLON.Color3.Black();
  m.freeze();
  return m;
}

// ----------------------
// Colors + radii
// ----------------------
const elementColors={
  H:new BABYLON.Color3(0.75,0.75,0.75),
  C:new BABYLON.Color3(0.2,0.2,0.2),
  N:new BABYLON.Color3(0.3,0.4,1),
  O:new BABYLON.Color3(1,0.2,0.2),
  S:new BABYLON.Color3(1,0.9,0.2),
  P:new BABYLON.Color3(1,0.5,0.2)
};
const covalentRadii={ H:0.31,C:0.76,N:0.71,O:0.66,S:1.05,P:1.07 };
const displayRadii={ H:0.6,C:1.2,N:1.1,O:1.1,S:1.4,P:1.4 };

// ----------------------
// CIF parsing (simple: ATOM lines)
// ----------------------
function parseCIFAtoms(text){
  const lines = text.split("\n");
  const atoms=[];
  for(const l of lines){
    if(!l.startsWith("ATOM")) continue;
    const p=l.trim().split(/\s+/);
    if(p.length<12) continue;
    atoms.push({ element:p[2], x:+p[9], y:+p[10], z:+p[11] });
  }
  return atoms;
}
function distSq(a,b){
  const dx=a.x-b.x,dy=a.y-b.y,dz=a.z-b.z;
  return dx*dx+dy*dy+dz*dz;
}
function distSq3(ax,ay,az,bx,by,bz){
  const dx=ax-bx,dy=ay-by,dz=az-bz;
  return dx*dx+dy*dy+dz*dz;
}

// ----------------------
// Load PSI CIF
// ----------------------
let psiText;
try{
  psiText = await (await fetch("photo_I.cif")).text();
}catch(e){
  infoEl.textContent = "Failed to load photo_I.cif.\nPut it next to this HTML and run via a local server (not file://).";
  throw e;
}

const atoms = parseCIFAtoms(psiText);
infoEl.textContent = "Atoms: "+atoms.length+"\nComputing bonds...";

// Spatial grid for bonds + picking
const cellSize=2;
const grid={};
function cellKey(x,y,z){ return Math.floor(x/cellSize)+"|"+Math.floor(y/cellSize)+"|"+Math.floor(z/cellSize); }
atoms.forEach((a,i)=>{ (grid[cellKey(a.x,a.y,a.z)] ??= []).push(i); });

// Bond detection
let bonds=[];
for(let i=0;i<atoms.length;i++){
  const a=atoms[i];
  const cx=Math.floor(a.x/cellSize), cy=Math.floor(a.y/cellSize), cz=Math.floor(a.z/cellSize);

  for(let dx=-1;dx<=1;dx++)
  for(let dy=-1;dy<=1;dy++)
  for(let dz=-1;dz<=1;dz++){
    const bucket = grid[(cx+dx)+"|"+(cy+dy)+"|"+(cz+dz)];
    if(!bucket) continue;

    for(const j of bucket){
      if(j<=i) continue;
      const b=atoms[j];
      const r1=covalentRadii[a.element]||0.7;
      const r2=covalentRadii[b.element]||0.7;
      const max=(r1+r2)*1.25;
      if(distSq(a,b) < max*max) bonds.push([i,j]);
    }
  }
}

// ----------------------
// ROOT + SPS Protein (atoms + bonds)
// ----------------------
const root = new BABYLON.TransformNode("root", scene);

// Atoms SPS
const baseSphere = BABYLON.MeshBuilder.CreateSphere("s", {diameter:1, segments:3}, scene);
baseSphere.isVisible = false;

const atomSPS = new BABYLON.SolidParticleSystem("psiAtomsSPS", scene);
atomSPS.addShape(baseSphere, atoms.length, {
  positionFunction:(p,i)=>{
    const a=atoms[i];
    const baseSize = displayRadii[a.element] || 1;
    const s = (a.element==="H") ? baseSize : baseSize*0.75;
    p.position.set(a.x,a.y,a.z);
    p.scaling.set(s,s,s);
    const c = elementColors[a.element] || new BABYLON.Color3(0.7,0.7,0.7);
    p.color = new BABYLON.Color4(c.r,c.g,c.b,1);
  }
});
const atomMesh = atomSPS.buildMesh();
atomMesh.parent = root;
atomMesh.isPickable = true;
atomMesh.material = makeVertexColorMat("psiAtomMat");
baseSphere.dispose();

// Bonds SPS (chunked)
const baseCyl = BABYLON.MeshBuilder.CreateCylinder("c",{height:1,diameter:0.4,tessellation:4},scene);
baseCyl.isVisible=false;

const MAX_BONDS_PER_SPS = 10000;
for(let start=0; start<bonds.length; start+=MAX_BONDS_PER_SPS){
  const chunk = bonds.slice(start, start+MAX_BONDS_PER_SPS);
  const bondSPS = new BABYLON.SolidParticleSystem("psiBondsSPS"+start, scene);

  bondSPS.addShape(baseCyl, chunk.length*2, {
    positionFunction:(p,i)=>{
      const pair = chunk[Math.floor(i/2)];
      const a = atoms[pair[0]];
      const b = atoms[pair[1]];

      const p1 = new BABYLON.Vector3(a.x,a.y,a.z);
      const p2 = new BABYLON.Vector3(b.x,b.y,b.z);
      const mid= BABYLON.Vector3.Lerp(p1,p2,0.5);

      const startPt = (i%2===0) ? p1 : mid;
      const endPt   = (i%2===0) ? mid : p2;

      const dir = endPt.subtract(startPt);
      const len = dir.length();

      p.position = startPt.add(dir.scale(0.5));
      p.scaling.y = len;

      const up = new BABYLON.Vector3(0,1,0);
      const dirNorm = dir.normalize();
      const axis = BABYLON.Vector3.Cross(up, dirNorm);
      const dot  = BABYLON.Vector3.Dot(up, dirNorm);

      if(axis.lengthSquared()>0.000001){
        const angle = Math.acos(Math.min(Math.max(dot,-1),1));
        p.rotationQuaternion = BABYLON.Quaternion.RotationAxis(axis.normalize(), angle);
      }else{
        p.rotationQuaternion = BABYLON.Quaternion.Identity();
      }

      const col = (i%2===0) ? elementColors[a.element] : elementColors[b.element];
      p.color = new BABYLON.Color4(col.r,col.g,col.b,1);
    }
  });

  const bondMesh = bondSPS.buildMesh();
  bondMesh.parent = root;
  bondMesh.material = makeVertexColorMat("psiBondMat"+start);
}
baseCyl.dispose();

// Center + scale PSI like you had
let minX=Infinity,minY=Infinity,minZ=Infinity;
let maxX=-Infinity,maxY=-Infinity,maxZ=-Infinity;
atoms.forEach(a=>{
  minX=Math.min(minX,a.x); minY=Math.min(minY,a.y); minZ=Math.min(minZ,a.z);
  maxX=Math.max(maxX,a.x); maxY=Math.max(maxY,a.y); maxZ=Math.max(maxZ,a.z);
});
const center = new BABYLON.Vector3((minX+maxX)/2,(minY+maxY)/2,(minZ+maxZ)/2);
root.position = center.scale(-1);
const maxDim = Math.max(maxX-minX, maxY-minY, maxZ-minZ);
root.scaling  = new BABYLON.Vector3(150/maxDim, 150/maxDim, 150/maxDim);
root.rotation.y = BABYLON.Tools.ToRadians(90);


camera.setTarget(BABYLON.Vector3.Zero());
camera.radius = 120;

const cameraStart = {
  alpha: camera.alpha, beta: camera.beta, radius: camera.radius, target: camera.target.clone()
};
document.getElementById("centerBtn").onclick = ()=>{
  camera.alpha = cameraStart.alpha;
  camera.beta  = cameraStart.beta;
  camera.radius= cameraStart.radius;
  camera.setTarget(cameraStart.target);
};

// ----------------------
// Picking -> nearest atom from pick point
// ----------------------
function pickAtomAndShowDialog(clientX, clientY){
  const pick = scene.pick(clientX, clientY, m=> m===atomMesh);
  if(!pick || !pick.hit || !pick.pickedPoint){
    dialog.style.display="none";
    return;
  }

  // convert picked world to protein-local coords
  const invRoot = root.getWorldMatrix().clone(); invRoot.invert();
  const pickedLocal = BABYLON.Vector3.TransformCoordinates(pick.pickedPoint, invRoot);

  const cx=Math.floor(pickedLocal.x/cellSize);
  const cy=Math.floor(pickedLocal.y/cellSize);
  const cz=Math.floor(pickedLocal.z/cellSize);

  let bestIdx=-1, bestD2=Infinity;
  for(let dx=-1;dx<=1;dx++)
  for(let dy=-1;dy<=1;dy++)
  for(let dz=-1;dz<=1;dz++){
    const bucket = grid[(cx+dx)+"|"+(cy+dy)+"|"+(cz+dz)];
    if(!bucket) continue;
    for(const i of bucket){
      const a = atoms[i];
      const d2 = distSq3(a.x,a.y,a.z, pickedLocal.x, pickedLocal.y, pickedLocal.z);
      if(d2<bestD2){ bestD2=d2; bestIdx=i; }
    }
  }

  if(bestIdx<0){ dialog.style.display="none"; return; }

  const a = atoms[bestIdx];
  dialogBody.textContent =
    "Index: " + bestIdx + "\n" +
    "Element: " + a.element + "\n" +
    "Local coords (Å):\n" +
    "  x = " + a.x.toFixed(3) + "\n" +
    "  y = " + a.y.toFixed(3) + "\n" +
    "  z = " + a.z.toFixed(3) + "\n";
  dialog.style.display="block";
}

// ----------------------
// Custom mouse controls
// Right drag = pan
// Ctrl+left drag = rotate
// Left click = pick
// ----------------------
let isCtrlDown=false;
window.addEventListener("keydown", e=>{ if(e.key==="Control") isCtrlDown=true; });
window.addEventListener("keyup",   e=>{ if(e.key==="Control") isCtrlDown=false; });

let dragging=false, dragMode=null;
let startX=0,startY=0,lastX=0,lastY=0,moved=false;

const PAN_PIXELS_TO_WORLD = 0.0016;
const ROT_SENS = 0.005;

canvas.addEventListener("pointerdown",(e)=>{
  canvas.setPointerCapture(e.pointerId);
  dragging=true; moved=false;
  startX=lastX=e.clientX; startY=lastY=e.clientY;

  if(e.button===2) dragMode="pan";
  else if(e.button===0 && isCtrlDown) dragMode="rotate";
  else dragMode=null;
});

canvas.addEventListener("pointermove",(e)=>{
  if(!dragging) return;

  const dx = e.clientX - lastX;
  const dy = e.clientY - lastY;

  if(Math.abs(e.clientX-startX)+Math.abs(e.clientY-startY)>4) moved=true;

  lastX = e.clientX;
  lastY = e.clientY;

  // ROTATE (Ctrl + left drag)
  if(dragMode==="rotate" && isCtrlDown){
    camera.alpha -= dx * ROT_SENS;
    camera.beta  -= dy * ROT_SENS;
    camera.beta = Math.max(camera.lowerBetaLimit, Math.min(camera.beta, camera.upperBetaLimit));
  }

  // PAN (right drag)
  if(dragMode==="pan"){
    const scale = camera.radius * PAN_PIXELS_TO_WORLD;
    const right = camera.getDirection(BABYLON.Axis.X);
    const up    = camera.getDirection(BABYLON.Axis.Y);

    camera.target.addInPlace(right.scale(-dx * scale));
    camera.target.addInPlace(up.scale(dy * scale));
  }
});


// ----------------------
// Havok Physics
// ----------------------
let havok;
try{
  havok = await HavokPhysics();
}catch(e){
  infoEl.textContent = "Havok failed to init.\nUse a local server (not file://).\n\nError:\n"+e;
  throw e;
}
const hk = new BABYLON.HavokPlugin(true, havok);
scene.enablePhysics(new BABYLON.Vector3(0,0,0), hk);

// Box boundaries
const boxSize = 120;
const half    = boxSize/2;
const t       = 2;

function makeWall(name, sx, sy, sz, px, py, pz){
  const m = BABYLON.MeshBuilder.CreateBox(name,{width:sx,height:sy,depth:sz},scene);
  m.isVisible=false;
  m.position.set(px,py,pz);
  new BABYLON.PhysicsAggregate(m, BABYLON.PhysicsShapeType.BOX,
    {mass:0, restitution:0.9, friction:0.1}, scene
  );
  return m;
}
makeWall("wall+X", t, boxSize, boxSize, +half, 0, 0);
makeWall("wall-X", t, boxSize, boxSize, -half, 0, 0);
makeWall("wall+Y", boxSize, t, boxSize, 0, +half, 0);
makeWall("wall-Y", boxSize, t, boxSize, 0, -half, 0);
makeWall("wall+Z", boxSize, boxSize, t, 0, 0, +half);
makeWall("wall-Z", boxSize, boxSize, t, 0, 0, -half);

// Visible box
const boxVis = BABYLON.MeshBuilder.CreateBox("boxVis",{size:boxSize, sideOrientation:BABYLON.Mesh.DOUBLESIDE},scene);
const boxMat = new BABYLON.StandardMaterial("boxMat",scene);
boxMat.disableLighting=true;
boxMat.emissiveColor=new BABYLON.Color3(0,0,1);
boxMat.specularColor= BABYLON.Color3.Black();
boxMat.alpha=0.05;
boxVis.material=boxMat;

// PSI proxy collider (sphere)
const psiRadius = 35;
const psiProxy = BABYLON.MeshBuilder.CreateSphere("psiProxy",{diameter:psiRadius*2,segments:8},scene);
psiProxy.isVisible=false;
psiProxy.position.set(0,0,0);
new BABYLON.PhysicsAggregate(psiProxy, BABYLON.PhysicsShapeType.SPHERE,
  {mass:0, restitution:0.9, friction:0.05}, scene
);

// ----------------------
// Water (instances + Havok bodies)
// ----------------------
const waterOMat    = makeFlatColorMat("waterOMat", elementColors.O);
const waterHMat    = makeFlatColorMat("waterHMat", elementColors.H);
const waterBondMat = makeFlatColorMat("waterBondMat", new BABYLON.Color3(0.6,0.6,0.6));


const baseO    = BABYLON.MeshBuilder.CreateSphere("wO",{diameter:2,segments:3},scene);
const baseH    = BABYLON.MeshBuilder.CreateSphere("wH",{diameter:1.2,segments:3},scene);
const baseBond = BABYLON.MeshBuilder.CreateCylinder("wB",{height:1,diameter:0.75,tessellation:4},scene);
baseO.material=waterOMat; baseH.material=waterHMat; baseBond.material=waterBondMat;
baseO.isVisible=false; baseH.isVisible=false; baseBond.isVisible=false;

// Water geometry
const OH = 2.0;
const waterAngle = 104.5 * Math.PI/180;
const hx = Math.sin(waterAngle/2)*OH;
const hz = Math.cos(waterAngle/2)*OH;

function setCylinderBetween(cyl, from, to){
  const mid = BABYLON.Vector3.Lerp(from,to,0.5);
  const dir = to.subtract(from);
  const len = dir.length();
  cyl.position.copyFrom(mid);
  cyl.scaling.y = len;

  const up = new BABYLON.Vector3(0,1,0);
  const dirNorm = dir.normalize();
  const axis = BABYLON.Vector3.Cross(up, dirNorm);
  const dot  = BABYLON.Vector3.Dot(up, dirNorm);
  if(axis.lengthSquared()>0.000001){
    const ang = Math.acos(Math.min(Math.max(dot,-1),1));
    cyl.rotationQuaternion = BABYLON.Quaternion.RotationAxis(axis.normalize(), ang);
  }else{
    cyl.rotationQuaternion = BABYLON.Quaternion.Identity();
  }
}

const waterCount = 120;
const bodies = [];
const baseSpeeds = [];
const WATER_SCALE = 1/3;   // 3x smaller

for(let i=0;i<waterCount;i++){
  // physics sphere body
  const body = BABYLON.MeshBuilder.CreateSphere("wBody"+i,{diameter:2.4,segments:6},scene);
  body.isVisible=false;

  // visible molecule transform (parented to body)
  const w = new BABYLON.TransformNode("water"+i, scene);
  w.parent = body;
  w.scaling.setAll(WATER_SCALE);

  const Oi  = baseO.createInstance("Oi"+i);  Oi.parent = w;
  const H1i = baseH.createInstance("H1i"+i); H1i.parent = w; H1i.position.set(hx,0,hz);
  const H2i = baseH.createInstance("H2i"+i); H2i.parent = w; H2i.position.set(-hx,0,hz);

  const B1i = baseBond.createInstance("B1i"+i); B1i.parent = w;
  const B2i = baseBond.createInstance("B2i"+i); B2i.parent = w;
  setCylinderBetween(B1i, BABYLON.Vector3.Zero(), H1i.position);
  setCylinderBetween(B2i, BABYLON.Vector3.Zero(), H2i.position);

  body.position.set(
    (Math.random()-0.5)*boxSize*0.7,
    (Math.random()-0.5)*boxSize*0.7,
    (Math.random()-0.5)*boxSize*0.7
  );

  const agg = new BABYLON.PhysicsAggregate(
    body, BABYLON.PhysicsShapeType.SPHERE,
    {mass:1, restitution:0.95, friction:0.02},
    scene
  );

  const v0 = new BABYLON.Vector3(
    (Math.random()-0.5)*2.0,
    (Math.random()-0.5)*2.0,
    (Math.random()-0.5)*2.0
  );
  agg.body.setLinearVelocity(v0);

  bodies.push(agg.body);
  baseSpeeds.push(v0.length() + 0.0001);
}

// ===== PLANAR CENTER CONSTRAINT =====
const PLANE_Z = 0;

scene.onBeforeRenderObservable.add(()=>{

  // ---- Constrain PSI center ----
  root.position.z = PLANE_Z;

  // ---- Constrain water molecule centers ----
  for(const b of bodies){

    const node = b.transformNode;
    if(node){
      node.position.z = PLANE_Z;  // center locked
    }

    const v = b.getLinearVelocity();
    if(v){
      v.z = 0;                    // remove only Z translation
      b.setLinearVelocity(v);
    }

    // keep rotation fully 3D
  }

});


// Slider controls water speed stably
const tmpV = new BABYLON.Vector3();
scene.onBeforeRenderObservable.add(()=>{
  for(let i=0;i<bodies.length;i++){
    const b = bodies[i];
    const v = b.getLinearVelocity();
    if(!v) continue;
    tmpV.copyFrom(v);
    const len = tmpV.length();
    if(len > 0.00001){
      const target = baseSpeeds[i] * speedMult;
      tmpV.scaleInPlace(target / len);
      b.setLinearVelocity(tmpV);
    }
  }
});

// ----------------------
// CLEAN SILHOUETTES (works between atoms, not only vs background)
// We do a screen-space outline pass using depth + color edge detection.
// This fixes "jumbled" outlines from mesh.renderOutline.
// ----------------------

// 1) Depth texture
const depthRenderer = scene.enableDepthRenderer(camera, false);
const depthTex = depthRenderer.getDepthMap();
depthTex.wrapU = depthTex.wrapV = BABYLON.Texture.CLAMP_ADDRESSMODE;

// 2) Outline post process shaders
BABYLON.Effect.ShadersStore["outlineFragmentShader"] = `
precision highp float;

varying vec2 vUV;

uniform sampler2D textureSampler;
uniform sampler2D depthSampler;
uniform vec2 texelSize;

uniform float depthThreshold;
uniform float edgeStrength;
uniform float thickness;

float depthAt(vec2 uv){
    return texture2D(depthSampler, uv).r;
}

void main(void){

    vec2 t = texelSize * thickness;

    float dC = depthAt(vUV);

    float depthEdge = 0.0;
    depthEdge = max(depthEdge, abs(dC - depthAt(vUV + vec2( t.x, 0.0))));
    depthEdge = max(depthEdge, abs(dC - depthAt(vUV + vec2(-t.x, 0.0))));
    depthEdge = max(depthEdge, abs(dC - depthAt(vUV + vec2(0.0,  t.y))));
    depthEdge = max(depthEdge, abs(dC - depthAt(vUV + vec2(0.0, -t.y))));

    float edge = smoothstep(depthThreshold, depthThreshold * 3.0, depthEdge);

    vec3 base = texture2D(textureSampler, vUV).rgb;

    vec3 outlined = mix(base, base * 0.25, edge * edgeStrength);

    gl_FragColor = vec4(outlined, 1.0);
}
`;


// 3) PostProcess that runs after the main render
const outlinePP = new BABYLON.PostProcess(
  "outlinePP",
  "outline",
  ["texelSize","depthThreshold","colorThreshold","edgeStrength","thickness"],
  ["depthSampler"],
  1.0,
  camera,
  BABYLON.Texture.BILINEAR_SAMPLINGMODE,
  engine,
  true
);

const BASE_RADIUS = 120;      
const BASE_THICKNESS = 0.1;   

outlinePP.onApply = (effect)=>{

  effect.setTexture("depthSampler", depthTex);

  effect.setFloat2(
    "texelSize",
    1.0 / engine.getRenderWidth(),
    1.0 / engine.getRenderHeight()
  );

  // --- Dynamic thickness scaling ---
  const zoomScale = BASE_RADIUS / camera.radius;
  let dynamicThickness = BASE_THICKNESS * zoomScale;

  // Clamp (min, max)
  dynamicThickness = BABYLON.Scalar.Clamp(
    dynamicThickness,
    0.05,   // minimum thickness
    3.0     // maximum thickness
  );

  effect.setFloat("depthThreshold", 0.000008);
  effect.setFloat("colorThreshold", 0.18);
  effect.setFloat("edgeStrength", 1.0);
  effect.setFloat("thickness", dynamicThickness);
};



// Resize: ortho + PP texel sizing stays correct automatically, but updateOrthoFromRadius too
window.addEventListener("resize", ()=>{
  engine.resize();

});

// ----------------------
// Info + render
// ----------------------
infoEl.textContent =
  "Camera: ArcRotateCamera (ORTHOGRAPHIC)\n" +
  "alpha=" + camera.alpha.toFixed(3) + " beta=" + camera.beta.toFixed(3) + " size=" + camera.radius.toFixed(1) + "\n\n" +
  "Atoms: " + atoms.length + "\n" +
  "Bonds: " + bonds.length + "\n" +
  "Waters (Havok): " + waterCount + "\n" +
  "Silhouette: depth+color (screen-space)\n";

// ===== CAMERA AUTO RETURN =====

const TARGET_ALPHA = Math.PI / 2;
const TARGET_BETA  = Math.PI / 2;
const RETURN_SPEED = 0.12;

scene.onBeforeRenderObservable.add(()=>{

  if(!isCtrlDown){

    const diffA = TARGET_ALPHA - camera.alpha;
    const diffB = TARGET_BETA  - camera.beta;

    camera.alpha += diffA * RETURN_SPEED;
    camera.beta  += diffB * RETURN_SPEED;

    camera.beta = BABYLON.Scalar.Clamp(
      camera.beta,
      camera.lowerBetaLimit,
      camera.upperBetaLimit
    );
  }

});


engine.runRenderLoop(()=>scene.render());

});
</script>
</body>
</html>

